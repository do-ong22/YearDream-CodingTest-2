```python
# 지시사항을 참고하여 코드를 작성하세요

n, m = map(int, input().split())
d = [m for _ in range(m + 1)]
d[0] = 0
for _ in range(n):
    a = int(input())
    for i in range(a, m + 1): 
        d[i] = min(d[i], d[i - a] + 1)
print(d[m])
```

## 해설

이 문제는 동적 프로그래밍(Dynamic Programming)을 활용하여 최소 동전 개수를 구하는 문제입니다.

### 문제 접근 방법
이 문제는 '최소 동전 개수 문제(Coin Change Problem)'의 전형적인 예로, 동적 프로그래밍 기법을 사용하면 효율적으로 해결할 수 있습니다.

### 코드 설명

1. 배열 초기화:
   ```python
   d = [m for _ in range(m + 1)]
   d[0] = 0
   ```
   - `d[i]`는 i원을 만들기 위해 필요한 최소 동전 개수를 저장합니다.
   - 초기값은 모든 금액에 대해 최대 가능한 값인 m으로 설정합니다(최악의 경우, 1원짜리 동전만 m개 사용).
   - `d[0] = 0`으로 설정하는 이유는 0원을 만들기 위해 필요한 동전 개수는 0개이기 때문입니다.

2. 동적 프로그래밍 과정:
   ```python
   for _ in range(n):
       a = int(input())
       for i in range(a, m + 1): 
           d[i] = min(d[i], d[i - a] + 1)
   ```
   - 각 동전 종류(a)에 대해 반복합니다.
   - a원부터 m원까지의 각 금액(i)에 대해, 현재 동전을 사용하지 않는 경우(`d[i]`)와 현재 동전을 사용하는 경우(`d[i - a] + 1`) 중 더 적은 동전을 사용하는 방법을 선택합니다.
   - 이때 `d[i - a] + 1`의 의미는 "i-a원을 만드는 최소 동전 개수 + 현재 동전 1개"입니다.

3. 결과 출력:
   ```python
   print(d[m])
   ```
   - m원을 만들기 위한 최소 동전 개수인 `d[m]`을 출력합니다.

### 시간 복잡도
- 동전의 종류는 n개이고, 각 동전마다 금액 범위(a~m)를 순회하므로 시간 복잡도는 O(n*m)입니다.

### 공간 복잡도
- 금액별 최소 동전 개수를 저장하는 배열을 사용하므로 공간 복잡도는 O(m)입니다.